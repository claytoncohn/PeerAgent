Approach 1: Brute Force
Intuition
To understand how we can construct Fibonacci sequence, we should first recall the defining property of a Fibonacci sequence: every number is the sum of the two preceding numbers. This means that once we have two numbers as a starting point, all subsequent numbers in the sequence are uniquely determined. For example, if we start with 2 and 3, the next number must be 5, then 8, then 13, and so on. This gives us our first insight: if we know the first two numbers of our subsequence, we can calculate all possible next numbers in the sequence.

So, our core strategy becomes: we'll try every possible pair of numbers from our array as starting points. For each pair, we'll attempt to build the longest possible Fibonacci-like sequence.

However, repeatedly searching through an array to check whether a number exists is inefficient. A simple optimization is to store all numbers in a hash set, allowing us to check for existence in constant time instead of scanning through the array repeatedly.

Now, let's walk through how we build sequences. We pick two numbers from the array — let's call them start and next—and consider them as the first two numbers of our Fibonacci-like sequence.

Since each new number in the sequence must be the sum of the previous two, we compute this sum and check whether it exists in our set. If it does, we have successfully extended the sequence, and we shift our window forward — our new pair now consists of the previous second number and the sum we just found. We repeat this process until we can no longer extend the sequence.

Throughout this process, we keep track of the longest sequence found using a variable maxLen. Once all loops are complete, maxLen holds the length of the longest Fibonacci-like sequence found, which we return as our answer.

Algorithm
Initialize:
a variable n to store the length of the input array
an empty hash set numSet to store the array elements.
Iterate through arr and add each element to the numSet.
Initialize a variable maxLen to 0 to track the length of the longest Fibonacci-like subsequence.
Use nested loops to try all possible combinations of the first two numbers, with outer loop variable start and inner loop variable next:
Initialize variables:
prev to store the second number (arr[next]).
curr to store the sum of first two numbers.
len to 2 (counting the first two numbers).
While the current sum exists in the numSet:
Store the current sum in a temporary variable.
Update curr to be the sum of previous two numbers.
Update prev to be the stored temporary value.
Increment len by 1 and update maxLen if the current length is greater.
Return the final value of maxLen (returns 0 if no valid subsequence was found).

Approach 2: Dynamic Programming
Intuition
In a Fibonacci-like sequence, each number depends on the two numbers that came before it. This suggests that if we know the length of a Fibonacci-like sequence ending with two particular numbers, we can use that information to find longer sequences that might include these numbers. This aspect of building larger sequences from information collected from smaller ones suggests a dynamic programming approach.

To structure this approach, we define a 2D DP array dp, where dp[i][j] represents the length of the longest Fibonacci-like sequence that ends with arr[i] and arr[j]. The indices i and j correspond to positions in our input array, with j always greater than i to maintain the strictly increasing order of the sequence.

The key idea is to determine whether a sequence ending in arr[i] and arr[j] can be extended. If these are the last two numbers of our sequence, then the number that came before them must be arr[j] - arr[i]. If this difference exists in our array and occurs before arr[i], we can extend a previous sequence to include arr[j].

For example, consider the array [3, 4, 5, 7, 9, 12]. Suppose we are examining 7 and 12 (at positions 3 and 5):

We compute the difference: 12 - 7 = 5.
We check whether 5 exists in the array and find it at position 2. Since 5 appears before 7, it can be part of a valid sequence.
This means we can extend an existing sequence that ended with [5, 7] by adding 12.
The length of the sequence ending with [7, 12] will then be one more than the length of the sequence ending with [5, 7], which we have already stored in our dp array.

To efficiently check for the existence of arr[j] - arr[i] in our array, we use a hash map valToIdx, which maps each value to its index. This allows quick lookups instead of searching the array repeatedly.

Now, to populate the dp array, we iterate over all pairs of indices (prev, curr) where curr > prev. We compute the difference arr[curr] - arr[prev] and check if it exists in the array. If it does, we extend the previously computed sequence; otherwise, we initialize a new sequence of length 2.

As we build dp, we maintain a variable maxLen to track the longest sequence found. Once we process all pairs, maxLen holds the length of the longest Fibonacci-like subsequence. If no valid sequence of at least three elements exists, we return 0.

For a more comprehensive understanding of hash tables, check out the Hash Table Explore Card. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.

Algorithm
Initialize:
a variable maxLen to 0 to track the length of the longest Fibonacci-like subsequence.
a 2D array dp of size arr.length × arr.length where dp[prev][curr] stores the length of the Fibonacci sequence ending at indexes prev and curr.
Initialize a hash map valToIdx to map each value in the array to its index.
For each current position curr in the array:
Add the mapping of the current value to its index in the valToIdx map.
For each previous position prev less than curr:
Calculate the difference diff between the current and previous values.
Look up the index prevIdx of diff in the valToIdx map (-1 if not found).
If diff is less than the previous value (ensuring strictly increasing sequence) and prevIdx exists:
Update dp[prev][curr] by adding 1 to the length of the sequence ending at [prevIdx][prev].
Otherwise:
Set dp[prev][curr] to 2 (representing just the two numbers).
Update maxLen if the current sequence length is greater.
Return maxLen if it's greater than 2, otherwise return 0 (as sequences of length 2 are not valid).
Here's a slideshow to visualize one iteration of the outer loop: