from agent import Agent
from globals import Config
import asyncio
import websockets
import json
from c2stem_state import C2STEMState
import logging
import threading
from c2stem_action import C2STEMAction
import time

"""
This is the entry file to the agent server implementation. 
The python file sets up the websocket connection and the user state for maintenance.
The file sends the chat window url on initialization to the front end.
The file listens to the messages on websocket and saves them to userState.
"""

#  Global variables and data structure
chat_window_URL = "URL= http://127.0.0.1:7860",
computational_model_state = C2STEMState()
agent = Agent(use_gui=True)


async def initialize_agent_server():
    """
    Initializes the agent server.

    This function initializes the WebSocket connection for the agent server. 
    It invokes the agent's talk` method. It also handles exceptions during initialization.

    Raises
    ------
    Exception
        If an error occurs while sending the URL or initializing the agent server.
    """
    agent.talk()


# Message handler for incoming message over the WebSocket.
async def handler(websocket):
    """
    Handles incoming WebSocket messages and maintains the user state.

    This function manages communication over a WebSocket connection. It:
    1. Establishes a new connection and assigns it to the `user_state`.
    2. Sends chat window URL to the client.
    3. Initializes the agent server for the connection.
    4. Processes incoming messages, which may include actions, user state updates, 
       or other types, and appropriately updates the `user_state`.

    Parameters
    ----------
    websocket : websockets.WebSocketServerProtocol
        The WebSocket connection object generated by the server.

    Raises
    ------
    websockets.exceptions.ConnectionClosed
        If the WebSocket connection is closed unexpectedly.
    Exception
        For any general errors that occur during message handling.

    Notes
    -----
    - Incoming messages are expected to be JSON formatted.
    - Recognized message types are "action" and "state". Unrecognized types are 
      returned back to the sender.
    - Invalid JSON messages are handled gracefully, returning an error response.
    """
    try:
        # Assigning websocket to user state to be used globally.
        computational_model_state.set_socket(websocket)
        global chat_window_URL
        try:
            # Hardcoded chat_window_URL to http://127.0.0.1:7860, as this is Gradio default
            await websocket.send(chat_window_URL)
            logging.info("Chat window URL sent to client.")
        except Exception as e:
            logging.error(f"Error initializing agent server: {e}")
        logging.info("New Websocket connection established")

        async for message in websocket:
            try:
                # Parse the incoming message
                message = json.loads(message)

                # Process C2STEM physics actions
                if message['type'] == "action":
                    action = C2STEMAction(message['data'])
                    if action.action_type not in {"togglePause","stopAllScripts"}:
                        agent.learner_model.actions.append(
                            {"time": action.t, "type": action.action_type, "block": action.block}
                        )
                        if len(agent.learner_model.actions) > Config.n_actions:
                            agent.learner_model.actions.popleft()
                        logging.info(f"Action added:\n{agent.learner_model.actions[-1]}")

                # Update the user model
                elif message['type'] == "state":
                    new_state = str(message['data'])
                    if new_state != computational_model_state.user_model:
                        computational_model_state.set_user_model(new_state)
                        agent.learner_model.user_model = computational_model_state.user_model
                        logging.info(f"User model updated: {agent.learner_model.user_model}")

                elif message['type'] == "group":
                    logging.info(f"User Action Group Updated: {str(message['data'])}")
                elif message['type'] == "score":
                    logging.info(f"User Action Score Updated: {message['data']}")
                else:
                    await websocket.send(message['data'])
            except json.JSONDecoderError:
                await websocket.send(json.dumps({"type": "error", "data": "Invalid JSON format."}))
                logging.error("Invalid message type received")
    except websockets.exceptions.ConnectionClosed as e:
        logging.error(f"WebSocket connection closed: {e}")
    except Exception as e:
        logging.error(f"Error in handler: {e}")

def run_websocket_server():
    """
    Starts and runs a WebSocket server on a separate thread.

    This function initializes and starts a WebSocket server that listens 
    on `ws://localhost:8080` using Python's `websockets` library. 
    The server runs indefinitely until a `KeyboardInterrupt` is received, 
    which gracefully shuts it down.

    The function uses an asyncio event loop to manage the asynchronous 
    WebSocket server and runs it indefinitely.

    Notes
    -----
    - The WebSocket server is designed to run on `ws://localhost:8080`.
    - The `handler` function should be defined elsewhere to process incoming 
      WebSocket connections.
    - Proper logging is used to record server startup and shutdown events.

    Raises
    ------
    KeyboardInterrupt
        If the server is interrupted manually, it shuts down gracefully.

    """
    async def websocket_server():
        logging.info("Starting WebSocket server on ws://localhost:8080")
        # Start the WebSocket server and run it indefinitely
        async with websockets.serve(handler, "localhost", 8080):
            try:
                await asyncio.Future()  # run forever
            except KeyboardInterrupt:
                logging.info("Shutting down the WebSocket server")

    # Run the WebSocket server using asyncio's event loop
    asyncio.run(websocket_server())

async def main():
    """
    This function creates and starts a WebSocket server that listens on
    `ws://localhost:8080` for incoming connections. It runs until manually
    terminated or interrupted.

    Raises
    ------
    KeyboardInterrupt
        If the server is manually terminated using a keyboard interrupt.
    """
    try:
        # Starts the WebSocket server in a separate thread.
        websocket_thread = threading.Thread(target=run_websocket_server, daemon=True)
        websocket_thread.start() # Start the thread

        # Run initialize_agent_server in the main thread
        await initialize_agent_server()
    except KeyboardInterrupt:
        # Graceful exit on Ctrl+C
        print("Program interrupted by user. Shutting down.")
    except Exception as e:
        # Handle unexpected errors
        print(f"An unexpected error occurred: {e}")

if __name__ =="__main__":
    """
    Entry point for the agent server script.

    Based on the environment (`Config.env`), this script either:
    1. Runs the `agent.talk` method in development mode.
    2. Starts the WebSocket server in production mode.
    3. Raises an exception if the environment is invalid.

    Raises
    ------
    Exception
        If `Config.env` is not set to "dev" or "prod".
    """
    if Config.env=="dev":
        agent.talk()
    elif Config.env=="prod":
        try:
            asyncio.run(main())
        except Exception as e:
            logging.error(f"Error running the server: {e}")
    else:
        raise Exception("Invalid environment. Must be 'dev' or 'prod'.")